Before messages can be exchanged securely in a communication system, the involved parties need to identify & authenticate each other, and then run any needed preliminary steps for further message exchanges. In most modern systems, this preliminary step involves a key-agreement protocol where a shared key is derived such that no single party has an undue influence in the final outcome. Despite being fundamental to most modern communication systems, some variation to this initial step of authentication and key-agreement is still fairly common. These variations can stem from differences in required security guarantees, message type and throughput, liveness of endpoints, compatibility with other protocols, ease of integration with existing systems and so on. Without necessary caution, a design can easily go from "fulfills minimum requirements" to one riddled with security loopholes, costly, unappealing and difficult to scale. 

Lets begin by providing a bit more detail on the above mentioned parameters that help pick suitable key-agreement protocol for a communication system.

1. Message Type and Throughput

    The reason message exchange is done with symmetric encryption is because it incurs less computational cost for messages of arbitrary length compared to doing it with asymmetric encryption. This makes key-agreement protocols attractive for systems requiring larger throughput. Encrypting message with a shared key is useful under private group messaging with several participants. Instead of sending a message to each participant by encrypting with their public key, a single message can be sent that is readable by all. 

2. Security Requirements

    Messages exchanged in systems using key-agreement protocols are not publicly verifiable (or have [deniability](https://en.wikipedia.org/wiki/Deniable_authentication) property) which means the encrypted message could have been generated by any of the parties in possession of the shared key making it difficult to know the source of encrypted message. **Deniability** property is favored in cases like secure e2e messaging while it is unacceptable for cryptographic logging schemes, [ransomware encryption](https://en.wikipedia.org/wiki/Ransomware#Encrypting_ransomware), etc. 

    Additionally end to end encrypted systems implement **Forward Secrecy and Post Compromise Security** features. These features ensure that the protocol refreshes shared key periodically (also when necessary). That way a bad actor in possession of shared key won't be able to deciper any other message encrypted with a different shared key. This property might also be useful if messages are logged in blockchain, which are like public bulletin boards. Without key refreshing, every single message exchanged so far, which is available in blockchains, can be decrypted.

3. Liveness of Endpoints

    Senders and receivers may not be online to run key-agreement protocol at the same time. This makes running the protocol difficult because the one who initiates the exchange has to hold secret values securely until the intended recepient can agree and send back an acknowledgement. Messaging in such situation is termed as **asynchronous messaging** and is common when communicating through smartphones, blockchains, etc. Protocols like [Extended Triple Diffie Hellman](https://signal.org/docs/specifications/x3dh) (X3DH, in short) are designed for asynchronous messaging and has found usage in e2e messaging applications like Signal, Whatsapp and even in web3 applications like XMTP, Lens Protocol, etc.
    
4. Protocol Compatibility

    Key-agreement protocols enforce security features necessitated by the usecase but they form only a cog in the overall design. Any other algorithms that precedes or comes down the line should also preserve the features required by the system. For example X3DH is used  for key-agreement in Signal Messaging app. It is used in unison with [Double Ratchet algorithm](https://signal.org/docs/specifications/doubleratchet), which forms the basis for payload exchange all the while preserving the same security features. Similarly, anonymity and end-to-encryption is preserved by zero knowledge proof based systems.

5. Ease of Integration

    This feature is loosely connected to key-agreement protocol, and instead aligns more with authentication mechanisms. The term *integration* here refers to more than technical compatibilty, which was already covered in the point above. Instead, here, we intend to discuss how a suitable protocol helps aid the communication system to more conveniently integrate with other applications and end-users. For example, lets consider a system where if you needed to run a key-agreement protocol, you'd need to be physically together, or consider a system where key-agreements can be run but only with the users which are already on your phone's contact list. Such designs make it [difficult to scale](https://signal.org/blog/contact-discovery/) the application to a larger userbase which in turn makes the application itself less appealing. Had authentication mechanisms been token gated such that holders of some NFT could authenticate and participate in the communication, then we'd be importing social value derived elsewhere in the ecosystem directly onto our system. In short, technical design should be wary of and facilitate inflow of business value.


Next we'll be taking a closer look on some of these protocols.

## X3DH
[X3DH](https://signal.org/docs/specifications/x3dh/) (or Extended Triple Diffie Hellman) protocol is a key agreement protocol used by secure messaging applications like Signal. It offers forward secrecy, deniability and is designed to work under asynchronous settings. In the following section, we progress from basic key-agreement protocol up to X3DH protocol describing the benefits of improvements in each step.

A basic Diffie-Hellman (DH) key-agreement protocol involves sender and receiver using their identity keys to calculate a shared key. A slight variation uses signed ephemeral key to calculate shared key. In the following diagrams, *A* and *B* are identity keys and *a* and *b* are ephemeral keys for a couple of users. The first (left) diagram shows ephemeral keys (a and b) signed by identity keys (A and B) and used for key-agreement. The benefit of using ephemeral key, which is renewed between protocol runs, is that it enables forward secrecy and provides protection against security breach if identity key was compromised.

An improvement to this protocol is shown on the next (right) diagram where instead of using identity key to sign respective ephemeral keys, three Diffie-Hellman shared keys are calculated and then combined to form a final shared key. This latter approach improves [deniability](https://signal.org/blog/simplifying-otr-deniability) and reduces payload size.

<img src="https://signal.org/blog/images/otr-current.png" alt="drawing" width=300 height=200/>
<img src="https://signal.org/blog/images/otr-simplified.png" alt="drawing" width=300 height=200/>

The description so far is for synchronous messaging, where both endpoints are online at the same time. For **asynchronous** settings, a user publishes a pre-key bundle, which the other user uses to establish shared key with the first user. For example, Bob publishes pre-key bundle which consists of the following.
 - Bob's identity key IK<sub>B</sub> generated once
 - Bob's signed prekey SPK<sub>B</sub> and prekey signature Sig(IK<sub>B</sub>, Encode(SPK<sub>B</sub>)) renewed periodically (weeks, months)
 - A set of Bob's one-time prekeys (OPKB<sub>1</sub>, OPKB<sub>2</sub>, OPKB<sub>3</sub>, ...) with each one for a separate protocol run

The use of ephemeral and one-time prekeys help enforce forward secrecy and avoid protocol replay. Alice fetches the pre-key bundle, uses her identity key, generates a new ephemeral key and calculates a shared key with the steps given below.

| CalculationSteps | Keys | KeyDescription |
| ---- | ----------- | --- |
| DH1 = DH(IK<sub>A</sub>, SPK<sub>B</sub>) | IK<sub>A</sub> | Alice's Identity Key |
| DH2 = DH(EK<sub>A</sub>, IK<sub>B</sub>) | EK<sub>A</sub> | Alice's Ephemeral Key |
| DH3 = DH(EK<sub>A</sub>, SPK<sub>B</sub>) | IK<sub>B</sub> | Bob's Identity Key |
| DH4 = DH(EK<sub>A</sub>, OPK<sub>B</sub>) | SPK<sub>B</sub> | Bob's Signed Prekey  |
| SK = KDF(DH1 \|\| DH2 \|\| DH3 \|\| DH4) | OPK<sub>B</sub> | Bob's One Time Prekey |

Here *DH(PK1, PK2)* represents Elliptic Curve Diffie Hellman Function whose output is a shared key derived from key-pair *PK1* and public-key *PK2* and *SK* is the combined shared key used for message exchange.

Afterwards, Alice provides Bob with a message containing her identity and ephemeral keys, Bob's prekey used and additional information encrypted with shared key. Bob receives the message and will be able to calculate shared key to communicate with Alice further.
<!-- <img src="https://signal.org/docs/specifications/x3dh/X3DH.png" alt="drawing" width=300 height=300/> -->

The protocol is widely used for e2e encrypted messaging and has found its use in [web3 applications](https://github.com/xmtp/litepaper#4-secure-web3-messaging-with-blockchain-accounts) as well where it has been used to exchange textual message, gameplay interaction signals, computational results and secrets, multimedia files, NFT metadata, application assets, etc.


## MLS
[MLS](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html) (or Messaging Layer Security) Protocol that provides efficient asynchronous group key establishment with forward secrecy and post-compromise security for groups in size ranging from two to thousands.

## Authentication with ABC, NFT and ZKP
We've, so far, learnt how parties can agree upon a key to to securely communicate with each other. But how do these parties identify and authenticate each other in the first place. Authentication mechanism itself is dependent upon wide range of factors like privacy sought, whether you're authenticating based on identity or attribute, whether you're authenticating a specific individual or anyone possessing some trait.  

1. Attribte Based Credential
    A user authenticates by providing proof of having an attribute (e.g. belonging to a group, of certain age) to the verifier. Attributes are generally unlinkable, which means two users submitting proof of an attribute (say, of age above 21) can not be distinguished based on the attribute alone. Such authentication mechanisms are applicable when you want to invite a large group of users, where anonymity is a concern, where the attributes themselves can be transferrable, revocable, obtainable. 
    It is used is Signal application where a user proves in zero knowledge that he is part of a private group.

3. Token gated
    Here, holders of a token (like NFTs) can prove their ownership and as such are able to authenticate. LensProtocol, BAYC



